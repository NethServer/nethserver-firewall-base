#!/usr/bin/perl

#
# Copyright (C) 2021 Nethesis S.r.l.
# http://www.nethesis.it - nethserver@nethesis.it
#
# This script is part of NethServer.
#
# NethServer is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License,
# or any later version.
#
# NethServer is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with NethServer.  If not, see COPYING.
#

##
## Parse the output of rrd file in a json content
##



use strict;
use warnings;
use JSON;
use esmith::ConfigDB;
use NethServer::Service;
use NethServer::ApiTools qw(readInput safe_decode_json);

require '/usr/libexec/nethserver/api/nethserver-firewall-base/lib/firewall_functions.pl';

my $input = readInput();
my $cmd = $input->{'action'};
my $cdb = esmith::ConfigDB->open_ro();
my $ndb = esmith::NetworksDB->open_ro();
my @ret;

sub slurp {
    my $file = shift;
    my $content;
    open(my $fh, '<', $file) or return '';
    {
        local $/;
        $content = <$fh>;
    }
    close($fh);
    return $content;
}

sub get_service_status {
    my $service = shift;
    my $cdb = shift;
    my $status = $cdb->get_prop($service, 'status') || "disabled";

    if ($status eq 'enabled') {
        my $s = NethServer::Service->new($service, $cdb);
	if ($s->is_running()) {
            $status = 'running';
        } else {
	    $status = 'failed';
	}
    }
    print encode_json({"status" => $status});
}

sub fetch_ping_rrd {
    my $file = shift;
    my $cdb = shift;
    my $time = shift;
    my @ret;
    my $systemname = $cdb->get_value('SystemName');
    my $domainname = $cdb->get_value('DomainName');
    my $path = "/var/lib/collectd/rrd/$systemname.$domainname/ping/$file.rrd";
    if (! -f $path) {
        return @ret;
    }
    open(FH, "rrdtool fetch $path AVERAGE -s e-$time|");
    while (<FH>) {
    chomp;
    my @lines = split("\r\n");
        foreach my $line (@lines) {
            my @values = split(":",$line);
            next unless $values[0] =~ m/\d/;
            next unless $values[1] =~ m/\d/;
            $values[1] =~ s/ //g;
            # be sure to output a numeric value
            $values[1] = $values[1]*1000;
            $values[0] = $values[0]*1000;
            push(@ret, \@values);
        }
    }
    close(FH);
    return @ret;   
}

if ($cmd eq 'ping') {
    my $time = $input->{'time'} || 900;
    my $ret;
    # ping_droprate
    # ping
    # collectd keeps track of the first DNS
    my @dns = split(',',$cdb->get_prop('dns', 'NameServers'));
    if (defined($dns[0])) {
        my @data = fetch_ping_rrd("ping-".$dns[0], $cdb, $time);
        if (@data) {
            $ret->{$dns[0]} = {labels => [ 'time','latency' ], data => \@data};
        }
    }

    # load extra configured hosts
    foreach my $h (split(",", $cdb->get_prop('collectd', 'PingHosts'))) {
        my @data = fetch_ping_rrd("ping-".$h, $cdb, $time);
        if (@data) {
            $ret->{$h} = {labels => [ 'time','latency' ], data => \@data};
        }
    }

    print encode_json ($ret);
} elsif ($cmd eq 'service') {

    my $service = $input->{'service'};

    # Each response must return a JSON object with the 'status' field.
    # Valid values for status are:
    #   - running
    #   - failed
    #   - disabled
    #   - warning
    # The response can also contain a 'details' field which can have any type.

    if ($service eq 'shorewall') {
        my $out = `/usr/sbin/shorewall status`;
        my $status = "failed";
        if ($? == 0) {
            $status = "running";
        }
        print encode_json({"status" => $status});
    } elsif ($service eq 'squid') {
        my $status = $cdb->get_prop('squid', 'status') || "disabled";
        my $details = {
            "green" => $cdb->get_prop('squid', 'GreenMode') || 'disabled',
            "blue" => $cdb->get_prop('squid', 'BlueMode') || 'disabled',
        };

        if ($status eq 'enabled') {
            my $s = NethServer::Service->new('squid', $cdb);
            if ($s->is_running()) {
                $status = 'running';
            } else {
                $status = 'failed';
            }
        }
        print encode_json({"status" => $status, "details" => $details});
    } elsif ($service eq 'internet') {
        my $dns = safe_decode_json(`/usr/libexec/nethserver/api/system-dns/hints`);
        my $ping = `/usr/bin/ping -c 1 www.nethserver.org`;
        my $ping_status = $?;
        my $status = "failed";
        if ($dns->{'count'} == 0 && $ping_status == 0) {
            $status = "running";
        } elsif ($dns->{'count'} > 0 && $ping_status == 0) {
            $status = "warning";
        }
        print encode_json({"status" => $status});
    } elsif ($service eq 'multiwan') {
        my $count = 0;
        my $failed = 0;
        my $status = 'disabled';
        foreach  ($ndb->red()) {
            $count++;
            my $file = '/var/lib/shorewall/'.$_->key.'.status';
            if (-f $file) {
                if (slurp($file) eq '1') {
                    $failed++;
                }
            }
        }
        if ($count > 1 && $failed == 0) {
            $status = 'running';
        } elsif ($count > 1 && $failed > 0 && $failed < $count) {
            $status = 'warning';
        } elsif ($count > 1 && $failed == $count) {
            $status = 'failed';
        }
        print encode_json({"status" => $status});
    } elsif ($service eq 'systemd') {
        my $status = "running";
        my $services = safe_decode_json(`/usr/libexec/nethserver/api/system-services/hints`);
        if ($services->{'count'} > 0) {
            $status = "warning";
        }
        print encode_json({"status" => $status});
    } elsif ($service eq 'ipblacklist') {
        my $status = $cdb->get_prop('blacklist', 'status') || "disabled";
        print encode_json({"status" => $status});
    } elsif ($service eq 'templates') {
        my $status = "disabled";
        my @files = `/usr/bin/find /etc/e-smith/templates-custom/ -type f`;
        if (@files) {
            $status = "warning";
        }
        print encode_json({"status" => $status, "details" => \@files});
    } elsif ($service eq 'antivirus') {
        get_service_status('c-icap', $cdb);
    } elsif ($service eq 'ntopng') {
        my $status = $cdb->get_prop($service, 'status') || "warning";
        my $details;

        if ($status eq 'enabled') {
            my $s = NethServer::Service->new($service, $cdb);
	    if ($s->is_running()) {
                $status = 'running';
            } else {
	        $status = 'failed';
	    }
        }
        foreach my $i (split(',',$cdb->get_prop('ntopng', 'Interfaces'))) {
            my $role = $ndb->get_prop($i, 'role') || next;
            $details->{$i} = $role;
        }
        print encode_json({"status" => $status, "details" => $details});

    } else {
        get_service_status($service, $cdb);
    }
} elsif ($cmd eq 'top-local-hosts') {
    system('echo \'{"action": "top-local-hosts"}\' | /usr/libexec/nethserver/api/nethserver-ntopng/dashboard/read');
} elsif ($cmd eq 'top-remote-hosts') {
    system('echo \'{"action": "top-remote-hosts"}\' | /usr/libexec/nethserver/api/nethserver-ntopng/dashboard/read');
}

